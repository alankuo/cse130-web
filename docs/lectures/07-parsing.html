<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="UCSD CSE 130">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://nadia-polikarpova.github.io/cse130-sp18//static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>cse130</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://nadia-polikarpova.github.io/cse130-sp18//static/img/ix.png" />
    <meta property="og:title" content="UCSD CSE 130" />
    <meta property="og:site_name" content="UCSD CSE 130" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/syntax.css">
    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://nadia-polikarpova.github.io/cse130-sp18/" id="blog-title-left-top">cse130</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//calendar.html">Calendar</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//contact.html">Contact</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//grades.html">Grades</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//lectures.html">Lectures</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//assignments.html">Assignments</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//links.html">Links</a></li>
                <li><a href="https://www.piazza.com/ucsd/spring2018/cse130/home" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>Piazza</a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://nadia-polikarpova.github.io/cse130-sp18//static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/polikarn" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/nadia-polikarpova" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/polikarn" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Nadia Polikarpova</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                              <a href="https://www.twitter.com/polikarn" target="_blank">follow</a>. <br>
                              <a href="https://www.github.com/nadia-polikarpova" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//calendar.html">Calendar</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//contact.html">Contact</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//grades.html">Grades</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//lectures.html">Lectures</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//assignments.html">Assignments</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//links.html">Links</a></li>
                              <li><a href="https://www.piazza.com/ucsd/spring2018/cse130/home" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>Piazza</a></li>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i>Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
    <header class="intro-header" style="background-image: url('https://nadia-polikarpova.github.io/cse130-sp18//static/img/books.jpg')" alt title>

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>A Quick Tutorial On Parsing</h1>
                    
                    <span class="meta">
		    
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->


<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
			<p>In this note we consider an invaluable programming tool, the <em>parser generator</em>. The problem that we want to solve is: how do we <strong>parse strings</strong>, that is, convert (unstructured) strings, the lowest-level representation of a program text, into (highly structured) representations like expressions, statements, functions <em>etc</em> which can then be compiled or interpreted.  Of course, the problem is much more general and arises in pretty much every large scale system, how do you convert raw data strings, into structured objects that can be manipulated by the rest of the system.  Of course, one can imagine various convoluted algorithms for extracting structure from strings. Indeed, you may well think that the conversion routine depends heavily on the <em>target</em> of the conversion! However, it turns out that we can design a small <em>domain-specific language</em> that describes a large number of the kinds of target structures, and we will use a <em>parser generator</em> that will automatically convert the structure description into a parsing function!  # An Arithmetic Interpreter  As a running example, let us build a small interpreter for a language of arithmetic expressions, described by the type  <sub><sub><sub><del>{.ocaml} type aexpr = | Const of int | Var of string | Plus of aexpr * aexpr | Minus of aexpr * aexpr | Times of aexpr * aexpr | Divide of aexpr * aexpr</del></sub></sub></sub>  shown in file (arithInterpreter.ml)[0]. This expression language is quite similar to what you saw for the random-art assignment, and we can write a simple recursive evaluator for it  <sub><sub><sub><del>{.ocaml} let foo x = match x with | C1 … -&gt; e1 | C2 … -&gt; e2  let foo = function | C1 … -&gt; e1 | C2 … -&gt; e2  let rec eval env e = match e with | Const i -&gt; i | Var s -&gt; List.assoc s env | Plus (e1, e2) -&gt; eval env e1 + eval env e2 | Minus (e1, e2) -&gt; eval env e1 - eval env e2 | Times (e1, e2) -&gt; eval env e1 * eval env e2 | Divide (e1, e2) -&gt; eval env e1 / eval env e2</del></sub></sub></sub>  Here the <code>env</code> is a <code>(string * int) list</code> corresponding to a list of variables and their corresponding values. Thus, if you run the above, you would see something like  <sub><sub><sub><del>{.ocaml} # eval [] (Plus (Const 2, Const 6)) ;; - : int = 4  # eval [(“x”,16); (“y”, 10)] (Minus (Var “x”, Var “y”)) ;; - : int = 6  # eval [(“x”,16); (“y”, 10)] (Minus (Var “x”, Var “z”)) ;; Exception: NotFound.</del></sub></sub></sub>~  Now it is rather tedious to write ML expressions like <code>Plus (Const 2, Const 6)</code>, and <code>Minus (Var &quot;x&quot;, Var &quot;z&quot;)</code>. We would like to obtain a simple parsing function  <sub><sub><sub><del>{.ocaml} val parseAexpr : string -&gt; aexpr</del></sub></sub></sub>  that converts a string to the corresponding <code>aexpr</code> if possible. For example, it would be sweet if we could get  <sub><sub><sub><del>{.ocaml} # parseAexpr “2 + 6” ;; - : aexpr = Plus (Const 2, Const 6)  # parseAexpr “(x - y) / 2” ;; - : aexpr = Divide (Minus (Var “x”, Var “y”), Const 2)</del></sub></sub></sub>  and so on. Lets see how to get there.  # Strategy  We will use a two-step strategy to convert raw strings into structured data.  ## Step 1 (Lexing) : From String to Tokens  Strings are really just a list of very low-level characters. In the first step, we will aggregate the characters into more meaningful <em>tokens</em> that contain more high-level information. For example, we will can aggregate a sequence of numeric characters into an integer, and a sequence of alphanumerics (starting with a lower-case alphabet) into say a variable name.  Thus, as a result of the lexing phase, we can convert a list of individual characters  <img src="../static/img/info_parser.001a.jpg" alt="Characters" id="fig:chars" style="width:70.0%" />  into a list of <em>tokens</em>  <img src="../static/img/info_parser.001b.jpg" alt="Tokens" id="fig:tokens" style="width:70.0%" />  ### Step 2 (Parsing) : From Tokens to Tree  Next, we will use a special description of the structures we are trying to generate called a <em>grammar</em> to convert the list of tokens into a tree-like representation of our final structure:  <sub><sub><sub><del>{.ocaml} - : aexpr = Plus (Const 229, Times (Const 98, Var “x2”))</del></sub></sub></sub>  The actual algorithms for converting from lists of tokens to trees are very subtle and sophisticated. We will omit a detailed description and instead just look at how the structures can themselves be represented by grammars.    Next, we get into the details of our the above strategy, by describing exactly what the lexer and parser (generators) do in terms of their input and output.  # Lexers  We will use the tool called <code>ocamllex</code> to automatically obtain a lexer from a high-level description of what the tokens are and what what sequences of characters should get mapped to tokens.  ## Tokens  The file (arithParser0.mly)[1] describes the set of tokens needed to represent our simple language  <sub><sub><sub><del>{.ocaml} %token <int> CONST %token <string> VAR %token PLUS MINUS TIMES DIVIDE %token LPAREN RPAREN %token EOF</del></sub></sub></sub>  Note that the first two tokens, <code>CONST</code> and <code>VAR</code> also carry values with them, respectively <code>int</code> and <code>string</code>.  ## Regular Expressions  Next, we must describe the sequences of characters that get aggregated into a particular token. This is done using (regular expressions)[7] defined in the file (arithLexer.mll)[2].  <sub><sub><sub><del>{.ocaml} { open ArithParser }  rule token = parse | eof { EOF } | [‘’ ‘’ ‘’ ‘’] { token lexbuf } | [‘0’-‘9’]+ as l { CONST (int_of_string l) } | [‘a’-‘z’][‘A’-‘z’]* as l { VAR l } | ‘+’ { PLUS } | ‘-’ { MINUS } | ’<em>‘{ TIMES } |’/‘{ DIVIDE } |’(‘{ LPAREN } |’)’ { RPAREN } <sub>~</sub>~~  the first line at top simply imports the token definitions from <code>arithParser.mly</code>. Next, there is a sequence of rules of the form <code>| &lt;regexp&gt;	{ml-expr}</code>.  Intuitively, each regular expression describes a sequence of characters, and when that sequence is matched in the input string, the corresponding ML expression is evaluated to obtain the token that is to be returned on the match. Let’s see some examples,  <sub><sub><sub><del>{.ocaml} | eof { EOF } | ‘+’ { PLUS } | ‘-’ { MINUS } | ’<em>‘{ TIMES } |’/‘{ DIVIDE } |’(‘{ LPAREN } |’)’ { RPAREN } <sub>~</sub>~~  - when the <code>eof</code> is reached (i.e. we hit the end of the string), a token called <code>EOF</code> is generated, similarly, when a character <code>+</code>, <code>-</code>, <code>/</code> etc. are encountered, the lexer generates the tokens <code>PLUS</code>, <code>MINUS</code>, <code>DIVIDE</code> etc. respectively,  <sub><sub><sub><del>{.ocaml} | [‘’ ‘’ ‘’ ‘’] { token lexbuf }</del></sub></sub></sub>  - <code>[c1 c2 ... cn]</code> where each <code>ci</code> is a character denotes a regular expression that matches <strong>any of</strong> the characters in the sequence. Thus, the regexp <code>[' ' '\n' '\t']</code> indicates that if either a blank or tab or newline is hit, the lexer should simply ignore it and recursively generate the token corresponding to the rest of the buffer,  <sub><sub><sub><del>{.ocaml} | [‘0’-‘9’]+ as l { CONST (int_of_string l) }</del></sub></sub></sub>  - <code>['0' - '9']</code> denotes a regexp that matches any digit-character. When you take a regexp and put a <code>+</code> in front of it, i.e. <code>e+</code> corresponds to <strong>one-or-more</strong> repetitions of <code>e</code>. Thus, the regexp <code>['0'-'9']+</code> matches a non-empty sequence of digit characters! Here, the variable <code>l</code> holds the exact substring that was matched, and we simply write <code>CONST (int_of_string l)</code> to return the <code>CONST</code> token carrying the <code>int</code> value corresponding to the matched substring.  <sub><sub><sub><del>{.ocaml} | [‘a’-‘z’][‘A’-‘z’ ‘0’-‘9’]* as l { VAR l }</del></sub></sub></sub>  - <code>e1 e2</code> denotes a regexp that matches any string <code>s</code> that can be split into two parts <code>s1</code> and <code>s2</code> (s.t. <code>s == s1 ^ s2</code>) where <code>s1</code> matches <code>e1</code> and <code>s2</code> matches <code>e2</code>. That is, <code>e1 e2</code> is a <strong>sequencing</strong> regexp that first matches <code>e1</code> and then matches <code>e2</code>.  - <code>e*</code> corresponds to <strong>zero-or-more repetitions</strong> of <code>e</code>. Thus, <code>['a'-'z']['A'-'z' '0'-'9']*</code> is a regexp that matches all strings that begin with a lower-case alphabet, and then have a (possibly empty) sequence of alpha-numeric characters. As before, the entire matching string is bound to the variable <code>l</code> and in this case the <code>VAR l</code> token is returned indicating that an identifier appeared in the input stream.  ## Running the Lexer  We can run the lexer directly to look at the sequences of tokens found. The function <code>Lexing.from_string</code> simply converts an input string into a buffer on which the actual lexer operates.  <sub><sub><sub><del>{.ocaml} # ArithLexer.token (Lexing.from_string “+”);; - : ArithParser.token = ArithParser.PLUS  # ArithLexer.token (Lexing.from_string “294”);; - : ArithParser.token = ArithParser.CONST 294</del></sub></sub></sub>  Next, we can write a function that recursively keeps grinding away to get all the possible tokens from a string (until it hits <code>eof</code>). When we call that function it behaves thus:  <sub><sub><sub><del>{.ocaml} # token_list_of_string “23 + + 92 zz /” ;; - : ArithParser.token list = [ArithParser.CONST 23; ArithParser.PLUS; ArithParser.PLUS; ArithParser.CONST 92; ArithParser.VAR “zz”; ArithParser.DIVIDE]  # token_list_of_string “23++92zz/” ;; - : ArithParser.token list = [ArithParser.CONST 23; ArithParser.PLUS; ArithParser.PLUS; ArithParser.CONST 92; ArithParser.VAR “zz”; ArithParser.DIVIDE]</del></sub></sub></sub>  Note that the above two calls produce exactly the same result, because the lexer finds </em>maximal* matches. </del></sub></sub></sub>{.ocaml} # token_list_of_string “92z” ;; - : ArithParser.token list = [ArithParser.CONST 92; ArithParser.VAR “z”] <sub>~</sub>~~  Here, when it hits the <code>z</code> it knows that the number pattern has ended and a new variable pattern has begun. Of course, if you give it something that doesn’t match anything, you get an exception  <sub><sub><sub><del>{.ocaml} # parse_string “%” ;; Exception: Failure “lexing: empty token”.</del></sub></sub></sub>  # Parsers  Next, will use the tool called <code>ocamlyacc</code> to automatically obtain a parser from a high-level description of the target structure called a <strong>grammar</strong>. (Note: grammars are very deep area of study, we’re going to take a very superficial look here, guided by the pragmatics of how to convert strings to <code>aexpr</code> values.)  ## Grammars  A grammar is a recursive definition of a set of trees, comprising  - Non-terminals and Terminals, which describe the internal and leaf nodes of the tree, respectively. Here, the leaf nodes will be tokens.  - Rules of the form  <sub><sub><sub><del>{.ocaml} nonterm : | term-or-nonterm-1 … term-or-non-term-n { Ocaml-Expr }</del></sub></sub></sub>  that describe the possible configuration of children of each internal node, together with an Ocaml expression that generates a </em>value* that is used to decorate the node. This value is computed from the values decorating the respective children.  We can define the following simple grammar for arith expressions: </del></sub></sub></sub>{.ocaml} aexpr: | aexpr PLUS aexpr { Plus ($1, $3) } | aexpr MINUS aexpr { Minus ($1, $3) } | aexpr TIMES aexpr { Times ($1, $3) } | aexpr DIVIDE aexpr { Divide ($1, $3) } | CONST { Const $1 } | VAR { Var $1 } | LPAREN aexpr RPAREN { $2 } <sub>~</sub>~~  Note that the above grammar (almost) directly mimics the recursive type definition of the expressions. In the above grammar, the <em>only</em> non-terminal is <code>aexpr</code> (we could call it whatever we like, we just picked the same name for convenience.) The terminals are the tokens we defined earlier, and each rule corresponds to how you would take the sub-trees (i.e. sub-expressions) and stitch them together to get bigger trees.  The line <code>%type &lt;ArithInterpreter.aexpr&gt; aexpr</code> at the top stipulates that each <code>aexpr</code> node will be decorated with a value of type <code>ArithInterpreter.aexpr</code> – that is, by a structured arithmetic expression.  Next, let us consider each of the rules in turn.  <sub><sub><sub><del>{.ocaml} | CONST { Const $1 } | VAR { Var $1 }</del></sub></sub></sub>  - The base-case rules for <code>CONST</code> and <code>VAR</code> state that those (individual) tokens can be viewed as corresponding to <code>aexpr</code> nodes. Consider the target expression in the curly braces.  Here <code>$1</code> denotes the value decorating the 1st (and only!) element of the corresponding non/terminal- sequence. That is, for the former (respectively latter) case <code>$1</code> the <code>int</code> (respectively <code>string</code> value) associated with the token, which we use to obtain the base arithmetic expressions via the appropriate constructors.  <sub><sub><sub><del>{.ocaml} | aexpr PLUS aexpr { Plus ($1, $3) } | aexpr MINUS aexpr { Minus ($1, $3) } | aexpr TIMES aexpr { Times ($1, $3) } | aexpr DIVIDE aexpr { Divide ($1, $3) }</del></sub></sub></sub>  - The inductive case rules, e.g. for the <code>PLUS</code> case says that if there is a token-sequence that is parsed into an <code>aexpr</code> node, followed by a <code>PLUS</code> token, followed by a sequence that is parsed into an <code>aexpr</code> node, then the <strong>entire</strong> sequence can be parsed into an <code>aexpr</code> node. Here <code>$1</code> and <code>$3</code> refer to the first and third elements of the sequence, that is, the <em>left</em> and <em>right</em> subexpressions. The decorated value is simply the super-expression obtained by applying the <code>Plus</code> constructor to the left and right subexpressions. The same applies to  <sub><sub><sub><del>{.ocaml} | LPAREN aexpr RPAREN { $2 }</del></sub></sub></sub>  - The last rule allows us to parse parenthesized expressions; if there is a left-paren token followed by an expresssion followed by a matching right-paren token, then the whole sequence is an <code>aexpr</code> node. Notice how the decorated expression is simply <code>$2</code> which decorates the second element of the sequence, i.e. the (sub) expression being wrapped in parentheses.  ## Running the Parser  Great, lets take our parser out for a spin! First, lets build the different elements  <sub>~</sub>~~{.ocaml} $ cp arithParser0.mly arithParser.mly  $ make clean rm -f *.cm[io] arithLexer.ml arithParser.ml arithParser.mli  $ make ocamllex arithLexer.mll 11 states, 332 transitions, table size 1394 bytes ocamlyacc arithParser.mly 16 shift/reduce conflicts. ocamlc -c arithInterpreter.ml ocamlc -c arithParser.mli ocamlc -c arithLexer.ml ocamlc -c arithParser.ml ocamlc -c arith.ml ocamlmktop arithLexer.cmo arithParser.cmo arithInterpreter.cmo arith.cmo -o arith.top <sub>~</sub>~~  Now, we have a specialize top-level with the relevant libraries baked in. So we can do:  <sub><sub><sub><del>{.ocaml} $ rlwrap ./arith.top Objective Caml version 3.11.2  # open Arith;;  # eval_string [] “1 + 3 + 6” ;; - : int = 10  # eval_string [(“x”, 100); (“y”, 20)] “x - y” ;; - : int = 80</del></sub></sub></sub>  And lo! we have a simple calculator that also supports variables.  ## Precedence and Associativity  Ok, looks like our calculator works fine, but lets try this  <sub><sub><sub><del>{.ocaml} # eval_string [] “2 * 5 + 5” ;; - : int = 20</del></sub></sub></sub>  Huh?! you would think that the above should yield <code>15</code> as <code>*</code> has higher precedence than <code>+</code> , and so the above expression is really <code>(2 * 5) + 5</code>. Indeed, if we took the trouble to put the parentheses in, the right thing happens  <sub><sub><sub><del>{.ocaml} # eval_string [] “(2 * 5) + 5” ;; - : int = 15</del></sub></sub></sub>  Indeed, the same issue arises with a single operator  <sub><sub><sub><del>{.ocaml} # eval_string [] “2 - 1 - 1” ;; - : int = 2</del></sub></sub></sub>  What happens here is that the grammar we gave is <strong>ambiguous</strong> as there are multiple ways of parsing the string <code>2 * 5 + 5</code>, namely  - <code>Plus (Times (Const 2, Const 5), Const 5)</code>, or - <code>Times (Const 2, Plus (Const 5, Const 5))</code>  We want the former, but ocamlyacc gives us the latter! Similarly, there are multiple ways of parsing <code>2 - 1 - 1</code>, namely  - <code>Minus (Minus (Const 2, Const 1), Const 1)</code>, or - <code>Minus (Const 2, Minus (Const 1, Const 1))</code>  Again, since <code>-</code> is left-associative, we want the former, but we get the latter! (Incidentally, this is why we got those wierd grumbles about <code>shift/reduce conflicts</code> when we ran <code>ocamlyacc</code> above, but lets not go too deep into that…)  There are various ways of adding precedence, one is to hack the grammar by adding various extra non-terminals, as done here (arithParser2.mly)[5]. Note how there are no conflicts if you use that grammar instead.  However, since this is such a common problem, there is a much simpler solution, which is to add precedence and associativity annotations to the .mly file. In particular, let us use the modified grammar (arithParser1.mly)[3].  <sub><sub><sub><del>{.ocaml} $ cp arithParser1.mly arithParser.mly $ make ocamllex arithLexer.mll 11 states, 332 transitions, table size 1394 bytes ocamlyacc arithParser.mly ocamlc -c arithInterpreter.ml ocamlc -c arithParser.mli ocamlc -c arithLexer.ml ocamlc -c arithParser.ml ocamlc -c arith.ml ocamlmktop arithLexer.cmo arithParser.cmo arithInterpreter.cmo arith.cmo -o arith.top</del></sub></sub></sub>  check it out, no conflicts this time! The only difference between this grammar and the previous one are the lines  <sub><sub><sub><del>{.ocaml} %left PLUS MINUS %left TIMES DIVIDE</del></sub></sub></sub>  This means that all the operators are <strong>left-associative</strong>  so <code>e1 - e2 - e3</code> is parsed as if it were <code>(e1 - e2) - e3</code>. As a result we get  <sub><sub><sub><del>{.ocaml} # eval_string [] “2 - 1 - 1” ;; - : int = 0</del></sub></sub></sub>  Furthermore, we get that addition and subtraction have lower precedence than multiplication and division (the order of the annotations matters!)  <sub><sub><sub><del>{.ocaml} # eval_string [] “2 * 5 + 5” ;; - : int = 15 # eval_string [] “2 + 5 * 5” ;; - : int = 27</del></sub></sub></sub>  Hence, the multiplication operator has higher precedence than the addition, as we have grown to expect, and all is well in the world.   This concludes our brief tutorial, which should suffice for your NanoML programming assignment. However, if you are curious, I encourage you to look at (this)[6] for more details.   [0]: http://goto.ucsd.edu/~rjhala/130/hw4/arith_notes/arithInterpreter.ml [1]: http://goto.ucsd.edu/~rjhala/130/hw4/arith_notes/arithParser0.mly [2]: http://goto.ucsd.edu/~rjhala/130/hw4/arith_notes/arithLexer.mll [3]: http://goto.ucsd.edu/~rjhala/130/hw4/arith_notes/arithParser1.mly [6]: http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ [7]: http://en.wikipedia.org/wiki/Regular_expression</p>
                <hr>
            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://nadia-polikarpova.github.io/cse130-sp18//feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/polikarn" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/nadia-polikarpova" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/jquery.min.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/spaceg.stylesheets.min.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/anim.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/scripts.js"></script>

    </body>
</html>
