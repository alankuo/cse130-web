<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="UCSD CSE 130">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://nadia-polikarpova.github.io/cse130-sp18//static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>cse130</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://nadia-polikarpova.github.io/cse130-sp18//static/img/ix.png" />
    <meta property="og:title" content="UCSD CSE 130" />
    <meta property="og:site_name" content="UCSD CSE 130" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/syntax.css">
    <link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://nadia-polikarpova.github.io/cse130-sp18//static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://nadia-polikarpova.github.io/cse130-sp18/" id="blog-title-left-top">cse130</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//calendar.html">Calendar</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//contact.html">Contact</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//grades.html">Grades</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//lectures.html">Lectures</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//assignments.html">Assignments</a></li>
                <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//links.html">Links</a></li>
                <li><a href="https://www.piazza.com/ucsd/spring2018/cse130/home" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>Piazza</a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://nadia-polikarpova.github.io/cse130-sp18//static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/polikarn" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/nadia-polikarpova" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/polikarn" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Nadia Polikarpova</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                              <a href="https://www.twitter.com/polikarn" target="_blank">follow</a>. <br>
                              <a href="https://www.github.com/nadia-polikarpova" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//calendar.html">Calendar</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//contact.html">Contact</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//grades.html">Grades</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//lectures.html">Lectures</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//assignments.html">Assignments</a></li>
                              <li><a href="https://nadia-polikarpova.github.io/cse130-sp18//links.html">Links</a></li>
                              <li><a href="https://www.piazza.com/ucsd/spring2018/cse130/home" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>Piazza</a></li>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i>Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
    <header class="intro-header" style="background-image: url('https://nadia-polikarpova.github.io/cse130-sp18//static/img/sea.jpg')" alt title>

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Logic Programming</h1>
                    
                    <span class="meta">
		    
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->


<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
			<h2 id="news">News</h2>
<p> - HW 5 is out, due Sun 6/11       ## Logic Programming  ### Traditional Languages  - <strong>Program</strong> = <strong>Algorithm</strong> + <strong>Data Structures</strong>  - <strong>Execute</strong>  ### Prolog  - <strong>Program</strong> = <strong>Facts</strong> + <strong>Rules</strong>  - <strong>Query</strong>  ## Logic Programming  <img src="../static/img/spock_logic.jpg" alt="Logic Programming" id="fig:spock" class="align-center" style="width:45.0%" />  ## Prolog History  - 1970s: Logic + Automated Theorem Proving  - Developed for <strong>Artificial Intelligence</strong>  ## Prolog : Original Vision “Expert Systems”  ### Collection of Facts  - <em>Carnitas is Mexican</em> isMexican(carnitas)  ### Collection of Rules  - <em>Mexican food is delicious</em> if isMexican(X) then isDelicious(X)  ### Queries  - <em>What is a delicious food ?</em> hey! solve for Y. s.t. isDelicious(Y)  ### Deductions  - <em>Carnitas!</em>  # You don’t RUN Prolog, you ASK it QUESTIONS  ## Declarative Programming  - Specify <strong>what</strong> you want  - Specify <strong>desired properties</strong> of result  - Not <strong>how</strong> to obtain result   # Declarative: Ideal for SEARCHING For Results  ## Declarative Programming  Ideal for Searching Large Space of Results  ### Philosophy  - It is often <strong>hard</strong> to specify <strong>search</strong> algorithm  - But <strong>easy</strong> to specify the characteristics of the solution.  # Declarative Programming Examples…  ## Declarative Programming: Orbitz/Expedia/etc.  ### Collection of Facts  - Airports, Flights, Times, Durations, Costs  ### Collection of Rules  - <strong>If</strong> travel from <code>A</code> to <code>B</code> with price (<code>P1</code>) <strong>AND</strong> <code>B</code> to <code>C</code> with price (<code>P2</code>)…  <strong>Then</strong>  - travel from <code>A</code> to <code>C</code> with price (<code>P1 + P2</code>) …  ### Queries  - What is cheapest flight from SAN to JFK with duration &lt; 6 Hrs ?   ## Declarative Programming: Linear Programming  ### Collection of Facts  - <strong>El Cuervo</strong> makes CA Burrito (profit = <code>$2</code>), Fish Taco (profit = <code>$1</code>)  ### Collection of Rules  - Burrito Capacity &lt; <code>200</code> - Taco Capacity &lt; <code>400</code> - Total Capacity &lt; <code>300</code>  ### Query: How many burritos and tacos to <strong>maximize</strong> profit?  <sub><sub><sub><del>{.scala} max 2.burr + 1.taco /* profit <em>/ s.t. burr &lt; 200 /</em> burrito capacity <em>/ taco &lt; 400 /</em> taco capacity <em>/ burr+taco &lt; 300 /</em> total capacity <em>/ 0 &lt;= burr 0 &lt;= taco /</em> must produce! <em>/  <sub>~</sub>~~  ## Declarative Programming  Used heavily in many domains (together with statistical methods)  - Scheduling - Travel, Sports, …  - Rule-based Anomaly detection - Credit card fraud!  - SQL (and similar DB Query Languages) - Find all pairs of stocks, with same price on same day, - More than 50 times last year  - Many of these are inspired-by / subsets of Prolog …  # Prolog: New Way To Think About Programming …  # Prolog: … Programming As Proving!  ## Plan  ### Language  1. Terms 2. Facts 3. Queries (Implementation: Unification) 4. Rules 5. Programs (Implementation: Backtracking Search)  ### Programming  - Numeric Computation - Data Structures - Puzzle Solving  ## Language: Terms  Prolog Program  - <strong>Facts</strong> - <strong>Rules</strong>  … but facts and rules <strong>about what</strong> ?  - Terms   ## Terms are Prolog’s way of representing Data  “Tree-like” values, similar to Ocaml ADTs  ### Four Kinds of Terms  1. <strong>Constants</strong>  2. <strong>Atoms</strong>  3. <strong>Variables</strong>  4. <strong>Compound Terms</strong>  ## Prolog Terms: Constants  <strong>Constants</strong> the simplest term, representing primitive values  - Basic types like integers, reals  - Examples: <code>1</code>, <code>92</code>, <code>4.4</code>    ## Prolog Terms: Atoms  <strong>Atom:</strong> any identifier starting with <strong>lower</strong>-case  - <code>x</code>, <code>alice</code>, <code>taco</code>, <code>giraffe</code>, <code>appleSauce</code>  # Atoms are NOT variables  ## Prolog Terms: Atoms  <strong>Atom:</strong> any identifier starting with <strong>lower</strong>-case  - <code>x</code>, <code>alice</code>, <code>taco</code>, <code>giraffe</code>, <code>appleSauce</code>  ### Atoms are not variables  - Elements of a single mega <strong>enum</strong> type  - Similar to tags used in ML types (except ML tags are uppercase)  - <code>type atoms = x | alice | taco | giraffe | appleSauce | ...</code>  ## Prolog Terms: Atoms  <strong>Atom:</strong> any identifier starting with <strong>lower</strong>-case  - <code>x</code>, <code>alice</code>, <code>taco</code>, <code>giraffe</code>, <code>appleSauce</code>  ### Atoms are Uninterpreted Constants (Names)  - Prolog knows <strong>NOTHING</strong> about the tags, they are just <strong>names</strong>  - Each tag is <strong>equal to</strong> itself (more later…) - <code>alice = alice</code> - <code>taco = taco</code>  - Each tag is <strong>disequal to</strong> every <strong>other</strong> tag - <code>alice = taco</code> <strong>never</strong> holds in Prolog  ## Prolog Terms: Variables  <strong>Variables:</strong> any identifier starting with <strong>upper</strong>-case  - <code>X</code>, <code>Y</code>, <code>Z</code>, <code>Head</code>, <code>Tail</code>, <code>Taco</code>, <code>Burrito</code>, <code>Alice</code>, <code>Bob</code>  - <code>_</code> is the <strong>wildcard</strong> variable, similar to <code>ML</code>   ### Variables are quite special …  - Even though <code>x = a</code> makes <strong>no sense</strong> to Prolog …  - … <code>X = a</code> does have a meaning but <strong>not</strong> what you might think!   # Warning: Upper vs. Lowercase leads to errors  ## Prolog Terms: Compound Terms  <strong>Compound</strong> terms are of form <code>atom(term1, term2, term3, ...)</code>  Where each <code>term</code> is <strong>one-of</strong>  - constant - atom - variable - compound term  ## Prolog Terms: Compound Terms  <strong>Compound</strong> terms are of form <code>atom(term1, term2, term3, ...)</code>  Where each <code>term</code> is <strong>one-of</strong>  - constant - atom - variable - compound term  ### Examples  <sub><sub><sub><del>{.prolog} x(y, z) % y, z are atoms parent(alice, bob) % alice, bob are atoms parent(alice, Child) % alice is an atom, Child is a variable</del></sub></sub></sub>   # Prolog Terms ARE NOT function calls  ## Prolog Compound Terms  - Terms are NOT Function Calls!  - More like <strong>trees</strong>  <img src="../static/img/prolog_tree1.png" width="400" align="middle" />   ## Prolog Terms: Compound Terms  <strong>Compound</strong> terms are of form <code>atom(term1, term2, term3, ...)</code>  Each <code>term</code> is <strong>one-of</strong>  - constant - atom - variable - compound term  ### An Ocaml Type For Prolog Terms  <sub><sub><sub><del>{.ocaml} type term = Constant of int | Atom of string | Variable of string | Compound of string * term list</del></sub></sub></sub>  ## QUIZ: An Ocaml Type For Prolog Terms  <sub><sub><sub><del>{.ocaml} type term = Constant of int | Atom of string | Variable of string | Compound of string * term list</del></sub></sub></sub>  (Hint: <strong>atom</strong> = lowercase, <strong>variable</strong> = uppercase)  Which <strong>Ocaml</strong> value of type <code>term</code> represents <strong>Prolog</strong> term  <code>parent(alice, bob)</code> ?  <strong>A.</strong> <code>parent (&quot;alice&quot;, &quot;bob&quot;)</code>  <strong>B.</strong> <code>parent (Atom &quot;alice&quot;, Atom &quot;bob&quot;)</code>  <strong>C.</strong> <code>[Atom &quot;parent&quot;; Atom &quot;alice&quot;; Atom &quot;bob&quot;]</code>  <strong>D.</strong> <code>Compound (&quot;parent&quot;, [Atom &quot;alice&quot;; Atom &quot;bob&quot;])</code>  <strong>E.</strong> <code>Compound (Atom &quot;parent&quot;, [Atom &quot;alice&quot;; Atom &quot;bob&quot;])</code>  ## Prolog Compound Terms  Prolog term <code>parent(alice, Charlie)</code> is represented by:  ### Ocaml Value  <sub><sub><sub><del>{.ocaml} Compound (“parent”, [Atom “alice”; Var “Charlie”])</del></sub></sub></sub>  ### Tree  <img src="../static/img/prolog_tree2.png" width="300" align="middle" />  ## QUIZ: An Ocaml Type For Prolog Terms  <sub><sub><sub><del>{.ocaml} type term = Constant of int | Atom of string | Variable of string | Compound of string * term list</del></sub></sub></sub>  (Hint: <strong>atom</strong> = lowercase, <strong>variable</strong> = uppercase)  What Ocaml value of type <code>term</code> represents Prolog term <code>factorial(5)</code> ?  <strong>A.</strong> <code>factorial(5)</code>  <strong>B.</strong> <code>factorial(Atom 5)</code>  <strong>C.</strong> <code>120</code>  <strong>D.</strong> <code>Constant 120</code>  <strong>E.</strong> <code>Compound (&quot;factorial&quot;, [Constant 5])</code>   ## Prolog Terms  Prolog term <code>factorial(5)</code> is simply the tree <img src="../static/img/prolog_tree3.png" width="200" align="middle" />  - The term is just a box containing <code>5</code> labeled <code>factorial</code>  ### Function Symbols  - <code>factorial</code> just a <strong>label</strong> called a <strong>function symbol</strong>  - Prolog has <strong>no idea</strong> about <strong>implementation</strong> of function …   # Prolog Terms = (Tree) Structured Data  ## Plan  ### Language  1. Terms 2. <strong>Facts</strong> 3. Queries (Implementation: Unification) 4. Rules 5. Programs (Implementation: Backtracking Search)  ### Programming  - Numeric Computation - Data Structures - Puzzle Solving  # Language: Facts  ## Language: Facts  ### Example  The following facts specify a list of <strong>parent-child</strong> relationships  <sub><sub><sub><del>{.prolog} parent(kim, holly).  parent(margaret, kim).  parent(herbert, margaret). parent(john, kim). parent(felix, john).  parent(albert, felix).</del></sub></sub></sub>  - <strong>Note</strong> <code>kim</code>, <code>holly</code>, <code>margaret</code> etc. are all <strong>atoms</strong>  - Facts are just terms (typically without variables.)  - Specified by term followed by <code>.</code>  ### Prolog maintains a Database of facts  - You can make up and add new facts to the collection  - We will be able to ask Prolog <strong>queries</strong> over these facts  ### Predicates = Function Symbols Used For Facts  - Represent functions that evaluate to a boolean  - e.g. <code>parent</code> is a predicate of <strong>arity</strong> 2 (that takes 2 arguments)  ### Predicates Are Just Names: No Meaning Or Implementation  - <code>parent</code> is a predicate of <strong>arity</strong> 2 (that takes two arguments)  - Programmer <strong>mentally</strong> notes that: - <code>parent(kim, holly)</code> <strong>means</strong> <code>kim</code> is a “parent-of” <code>holly</code> - <code>parent(margaret, kim)</code> <strong>means</strong> <code>margaret</code> is a “parent-of” <code>kim</code> - etc.  ## Plan  ### Language  1. Terms 2. Facts 3. <strong>Queries</strong> (Implementation: Unification) 4. Rules 5. Programs (Implementation: Backtracking Search)  ### Programming  - Numeric Computation - Data Structures - Puzzle Solving  # Running Prolog via Queries  ## Language: Queries  Standard interface is a REPL shell  <sub><sub><sub><del>{.prolog} $ rlwrap swipl  130f@ieng6-202]:~:501$ swipl Welcome to SWI-Prolog (Multi-threaded, 32 bits, Version 5.10.5) Copyright (c) 1990-2011 University of Amsterdam, VU Amsterdam SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software, and you are welcome to redistribute it under certain conditions. Please visit http://www.swi-prolog.org for details.  For help, use ?- help(Topic). or ?- apropos(Word).  ?-</del></sub></sub></sub>  ## Language: Queries  Suppose we have a collection of facts saved in <a href="../lectures/lec-prolog.pl">lec-prolog.pl</a>  You can <strong>load</strong> the facts in …  <sub><sub><sub><del>{.prolog} ?- consult(‘lec-prolog.pl’). % foo.pl compiled 0.00 sec, 10,640 bytes true.</del></sub></sub></sub>  … or you can <strong>add</strong> them one-at-a-time  <sub><sub><sub><del>{.prolog} ?- assert(parent(margaret, kim)).</del></sub></sub></sub>  ## Language: Queries  Once facts are loaded, you <strong>query</strong> Prolog as follows:  1. <strong>Plg:</strong> Prompts you to type a query  2. <strong>You:</strong> Type a query  3. <strong>Plg:</strong> Tries to </em>prove* your query  4. <strong>Plg:</strong> Prints out the result (or <code>failure</code>)  5. Repeat (go to 1)   # Lets ask some questions!  ## Language: Queries  The simplest possible query … </del></sub></sub></sub>{.prolog} ?- parent(margaret, john).  <sub>~</sub>~~  … a <strong>fact</strong> but typed at the prompt.  ## Language: Queries  The simplest possible query …  <sub><sub><sub><del>{.prolog} ?- parent(margaret, john). </del></sub></sub></sub>  … a <strong>fact</strong> but typed at the prompt.  ### Meaning  O Prolog, is this fact <strong>in</strong> your Database … or can it be <strong>inferred</strong> from your database?  ## Language: Queries  The simplest possible query …  <sub><sub><sub><del>{.prolog} ?- parent(margaret, john). </del></sub></sub></sub>  … a <strong>fact</strong> but typed at the prompt.  ### Meaning  O Prolog, is this fact <strong>in</strong> your database … or can it be <strong>inferred</strong> from your database?  ### Prolog Replies  <sub><sub><sub><del>{.prolog} ?- parent(margaret, john). false.</del></sub></sub></sub>  - This is <strong>not</strong> one of the facts we gave it, and, - We are yet to supply it with <strong>rules</strong> for inferring <strong>new facts</strong>.  ## Language: Queries  A slightly different query yields a different result.  ## Language: Queries  A slightly different query yields a different result.  <sub><sub><sub><del>{.prolog} ?- parent(margaret, kim).  true.</del></sub></sub></sub>  - As this was indeed one of the facts loaded in <a href="../lectures/lec-prolog.pl">lec-prolog</a>  # Pfft. Big deal? Is Prolog just a table lookup?!  # Things get more interesting when queries have variables …  ## Queries With Variables  This is where Prolog starts to depart radically from other paradigms…  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X).</del></sub></sub></sub>  <br>  ### Meaning  O Prolog, for <strong>which value(s)</strong> of <code>X</code> is the fact <strong>provable</strong> ?  ## Queries With Variables  This is where Prolog starts to depart radically from other paradigms…  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X).</del></sub></sub></sub>  <br>  ### Meaning  O Prolog, for <strong>which value(s)</strong> of <code>X</code> is the fact <strong>provable</strong> ?   ### Prolog Replies  <sub><sub><sub><del>{.prolog} X = kim.</del></sub></sub></sub>  As when prolog <strong>plugs-in</strong> <code>kim</code> for <code>X</code>,  - It can infer <code>parent(margaret, kim)</code>.  ## Queries With Variables  Suppose we <em>flip</em> the query.  <sub><sub><sub><del>{.prolog} ?- parent(X, kim).</del></sub></sub></sub>  O Prolog, for <strong>which value(s)</strong> of <code>X</code> is <code>parent(X, kim)</code> <strong>provable</strong> ?  ## Queries With Variables  Suppose we <em>flip</em> the query.  <sub><sub><sub><del>{.prolog} ?- parent(X, kim).</del></sub></sub></sub>  O Prolog, who are the <strong>parents-of</strong> <code>kim</code>?  ## Queries With Variables  Suppose we <em>flip</em> the query.  <sub><sub><sub><del>{.prolog} ?- parent(X, kim).</del></sub></sub></sub>  O Prolog, who are the <strong>parents-of</strong> <code>kim</code>?  ### Prolog Replies  <sub><sub><sub><del>{.prolog} ?- parent(X, kim). X = margaret ; % [press ‘;’ if you want another solution] X = john ; % [press ‘;’ if you want another solution] false. % [thats all folks, no more solutions ]</del></sub></sub></sub>  <br>  Returns <strong>all solutions</strong> for <code>X</code> that make <code>parent(X, kim)</code> provable.  ## Queries With Variables  We can write queries with <em>multiple</em> variables.  <sub><sub><sub><del>{.prolog} ?- parent(X, Y).</del></sub></sub></sub>  O Prolog, for which pairs <code>X</code>, <code>Y</code> is <code>parent(X, Y)</code> provable?  ## Queries With Variables  We can write queries with <em>multiple</em> variables.  <sub><sub><sub><del>{.prolog} ?- parent(X, Y).</del></sub></sub></sub>  O Prolog, for which pairs <code>X</code>, <code>Y</code> is <code>parent(X, Y)</code> provable?  ### Prolog Replies  <sub><sub><sub><del>{.prolog} ?- parent(X, Y). X = kim, Y = holly ; X = margaret, Y = kim ; X = herbert, Y = margaret; X = john, Y = kim ; X = felix, Y = john ; X = albert, Y = felix ; X = albert, Y = dana ; X = felix, Y = maya .</del></sub></sub></sub>  Enumerates <strong>all facts</strong> in the <code>parent</code> database.  ## QUIZ: Queries With Variables  Suppose we want to know if there are any strange circularities in the database:  &gt; Does there exist <strong>any</strong> person who is their <strong>own parent</strong> ?  Which of the following encodes the above in Prolog?  <strong>A.</strong> <code>parent(kim, kim)</code>  <strong>B.</strong> <code>parent(x, x)</code>  <strong>C.</strong> <code>parent(X, X)</code>  <strong>D.</strong> <code>parent(X, Y)</code>  <strong>E.</strong> <code>parent(Y, X)</code>  # Queries are magic! <img src="http://www.cartoonstock.com/newscartoons/cartoonists/bst/lowres/bstn414l.jpg" width="300" align="middle" />  ## Queries Work Like Magic  In Java/C# or for that matter ML/Scala/… you would need  - Some <code>parentOf</code> or <code>childOf</code> methods - to represent parent-child relationship  - Some looping or iteration - to search through all pairs  - Instead, Prolog uses <strong>facts</strong> and <strong>queries</strong> - to search <strong>forwards</strong> and <strong>backwards</strong> - to enumerate all results - in a single uniform <strong>declarative</strong> manner!  # Magic = Unification + Backtracking Search  ## Plan  ### Language  1. Terms 2. Facts 3. Queries (Implementation: <strong>Unification</strong>) 4. Rules 5. Programs (Implementation: Backtracking Search)  ### Programming  - Numeric Computation - Data Structures - Puzzle Solving  # Unification: Prolog’s <strong>computational heart</strong>  # Unification: When does one term MATCH another?  ## Unification  ### Two Terms Can Be Unified If  We can <strong>substitute</strong> values for their <strong>variables</strong> to make the terms <strong>identical</strong>  ## Unification  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  ### Equality Is Unification  In Prolog, when you write (e.g. in a query)  <sub><sub><sub><del>{.prolog} ?- term1 = term2.</del></sub></sub></sub>  you are asking whether <code>term1</code> <strong>can be unified with</strong> <code>term2</code>.  # Unification By Example  ## Unification: Atoms  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  ### Example  <sub><sub><sub><del>{.prolog} ?- kim = kim. true.</del></sub></sub></sub>  Two <strong>same atoms</strong> are <strong>trivially</strong> unified.  ## Unification: Atoms  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  ### Example  <sub><sub><sub><del>{.prolog} ?- kim = holly. false.</del></sub></sub></sub>  Two <strong>different atoms</strong> can <strong>never</strong> be unified.  ## Unification: Compound Terms Are Recursively Unified  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  ### Example  <sub><sub><sub><del>{.prolog} ?- foo(kim) = foo(kim). true.</del></sub></sub></sub>  As there are no variables, and the terms <strong>are already</strong> identical.   ### Example  <sub><sub><sub><del>{.prolog} ?- foo(kim) = foo(holly). false.</del></sub></sub></sub>  As there are no variables, and the terms <strong>can never be</strong> identical.  ## Unification: Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  ### Example  <sub><sub><sub><del>{.prolog} ?- X = kim.</del></sub></sub></sub>  - <strong>Q:</strong> When is the term <code>X</code> <strong>identical to</strong> the term <code>kim</code>?  - <strong>A:</strong> When we <strong>substitute</strong> <code>X</code> with the value <code>kim</code>!  ## Unification: Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  ### Example  <sub><sub><sub><del>{.prolog} ?- foo(X) = foo(kim).</del></sub></sub></sub>  - <strong>Q:</strong> When is the term <code>X</code> <strong>identical to</strong> the term <code>kim</code>?  - <strong>A:</strong> When we <strong>substitute</strong> <code>X</code> with the value <code>kim</code>!  ### Prolog Responds  <sub><sub><sub><del>{.prolog} ?- foo(X) = foo(kim). X = kim.</del></sub></sub></sub>  - Pretty simple…  ## QUIZ: Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  How does Prolog respond to the following query?  <sub><sub><sub><del>{.prolog} ?- foo(X, dog) = foo(cat, Y).</del></sub></sub></sub>  <strong>A.</strong> <code>false</code>  <strong>B.</strong> <code>X = cat, Y = cat.</code>  <strong>C.</strong> <code>X = dog, Y = dog.</code>  <strong>D.</strong> <code>X = dog, Y = cat.</code>  <strong>E.</strong> <code>X = cat, Y = dog.</code>   ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  <img src="../static/img/prolog_unify_1.png" width="500" align="middle" />  The <strong>top</strong> nodes of both trees have <strong>same predicate</strong> … go inside.  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  <img src="../static/img/prolog_unify_2.png" width="500" align="middle" />  To unify <code>X</code> and <code>cat</code> use <strong>substitution</strong> <code>X = cat</code>  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  <img src="../static/img/prolog_unify_3.png" width="500" align="middle" />  Apply substitution <code>X = cat</code> to both terms. Move on to next leaf…  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  <img src="../static/img/prolog_unify_4.png" width="500" align="middle" />  To unify <code>dog</code> and <code>Y</code> use <strong>substitution</strong> <code>Y = dog</code> …  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  <img src="../static/img/prolog_unify_5.png" width="500" align="middle" />  … and apply substitution throughout <strong>both</strong> terms.  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  <img src="../static/img/prolog_unify_6.png" width="500" align="middle" />  Uh oh, now last leaf has <strong>different</strong> atoms…  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y).</del></sub></sub></sub>  <img src="../static/img/prolog_unify_7.png" width="500" align="middle" />  … impossible to unify <code>cat</code> and <code>dog</code>. <strong>Unification fails.</strong>  ## Unification With Multiple Variables  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  <sub><sub><sub><del>{.prolog} ?- p(X, dog, X) = p(cat, Y, Y). false.</del></sub></sub></sub>  <img src="../static/img/prolog_unify_7.png" width="500" align="middle" />  ## QUIZ: Recursively Unify Subtrees  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  How does Prolog respond to the following unification query?  <sub><sub><sub><del>{.prolog} ?- a(W, foo(W, Y), Y) = a(2, foo(X, 3), Z).</del></sub></sub></sub>  <strong>A.</strong> <code>false.</code> (No unification possible)  <strong>B.</strong> <code>W = 2, X = 2, Y = 2, Z = 2.</code>  <strong>C.</strong> <code>W = 2, X = 2, Y = 3, Z = 3.</code>  <strong>D.</strong> <code>W = 3, X = 3, Y = 2, Z = 2.</code>  <strong>C.</strong> <code>W = 2, X = 3, Y = 2, Z = 3.</code>   ## Recursively Unify Subtrees  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  How does Prolog respond to the following unification query?  <sub><sub><sub><del>{.prolog} ?- a(W, foo(W, Y), Y) = a(2, foo(X, 3), Z).</del></sub></sub></sub>  1. Subst <code>W = 2</code>. Query is: <code>a(2, foo(2, Y), Y) = a(2, foo(X, 3), Z).</code>  2. Subst <code>X = 2</code>. Query is: <code>a(2, foo(2, Y), Y) = a(2, foo(2, 3), Z).</code>  3. Subst <code>Y = 3</code>. Query is: <code>a(2, foo(2, 3), 3) = a(2, foo(2, 3), Z).</code>  4. Subst <code>Z = 3</code>. Query is: <code>a(2, foo(2, 3), 3) = a(2, foo(2, 3), 3).</code>  5. <strong>Done!</strong>  ## Recursively Unify Subtrees  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  How does Prolog respond to the following unification query?  <sub><sub><sub><del>{.prolog} ?- a(W, foo(W, Y), Y) = a(2, foo(X, 3), Z). W = 2, X = 2, Y = 3, Z = 3.</del></sub></sub></sub>  ## QUIZ: Recursively Unify Subtrees  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  How does Prolog respond to the following unification query?  <sub><sub><sub><del>{.prolog} ?- a(W, foo(W, Y), Y) = a(2, foo(X, 3), X).</del></sub></sub></sub>  <br><br>  <strong>A.</strong> <code>false.</code> (No unification possible)  <strong>B.</strong> <code>W = 2, X = 2, Y = 2, Z = 2.</code>  <strong>C.</strong> <code>W = 2, X = 2, Y = 3, Z = 3.</code>  <strong>D.</strong> <code>W = 3, X = 3, Y = 2, Z = 2.</code>  <strong>E.</strong> <code>W = 2, X = 3, Y = 2, Z = 3.</code>  ## Recursively Unify Subtrees  ### Two terms can be <em>unified</em> if we can <em>substitute</em> values for variables to make the terms <em>identical</em>  How does Prolog respond to the following unification query?  <sub><sub><sub><del>{.prolog} ?- a(W, foo(W, Y), Y) = a(2, foo(X, 3), X).</del></sub></sub></sub>  1. Subst <code>W = 2</code>. Query is: <code>a(2, foo(2, Y), Y) = a(2, foo(X, 3), X).</code>  2. Subst <code>X = 2</code>. Query is: <code>a(2, foo(2, Y), Y) = a(2, foo(2, 3), 2).</code>  3. Subst <code>Y = 3</code>. Query is: <code>a(2, foo(2, 3), 3) = a(2, foo(2, 3), 2).</code>  4. <code>3 = 2</code> cannot be unified, <strong>Fail!</strong>   # Unification: Powerful Way To Answer Queries  ## Unification is a Powerful Way To Answer Queries  When we ask  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X). </del></sub></sub></sub>  Prolog checks if the above term <strong>can be unified</strong> with any <strong>known fact</strong> (term).  - If <strong>unification succeeds</strong> then it replies <code>true</code> - And also the <strong>unifying substitutions</strong> for <code>X</code> - Which are the <strong>solutions</strong> for the query!  - If <strong>unification fails</strong> then it replies <code>false</code>  ## Unification is a Powerful Way To Answer Queries  When we ask  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X). </del></sub></sub></sub>  Prolog checks if the above term <strong>can be unified</strong> with any <strong>known fact</strong> (term).  - If <strong>unification succeeds</strong> then it replies <code>true</code> (and the <strong>solutions</strong> for <code>X</code>) - If <strong>unification fails</strong> then it replies <code>false</code>  ### Above Query Has <strong>One Solution</strong>  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X).  X = kim.</del></sub></sub></sub>  ## Unification is a Powerful Way To Answer Queries  When we ask  <sub><sub><sub><del>{.prolog} ?- parent(X, kim). </del></sub></sub></sub>  ## Unification is a Powerful Way To Answer Queries  When we ask  <sub><sub><sub><del>{.prolog} ?- parent(X, kim). </del></sub></sub></sub>  Prolog checks if the above term <strong>can be unified</strong> with any <strong>known fact</strong> (term).  - If <strong>unification succeeds</strong> then it replies <code>true</code> (and the <strong>solutions</strong> for <code>X</code>) - If <strong>unification fails</strong> then it replies <code>false</code>    ## Unification is a Powerful Way To Answer Queries  When we ask  <sub><sub><sub><del>{.prolog} ?- parent(X, kim). </del></sub></sub></sub>  Prolog checks if the above term <strong>can be unified</strong> with any <strong>known fact</strong> (term).  - If <strong>unification succeeds</strong> then it replies <code>true</code> (and the <strong>solutions</strong> for <code>X</code>) - If <strong>unification fails</strong> then it replies <code>false</code>   ### This Query Has <strong>Many Solutions</strong>  <sub><sub><sub><del>{.prolog} ?- parent(X, kim).  X = margaret ; X = john .</del></sub></sub></sub>  ## Unification is a Powerful Way To Answer Queries  Finally, when we ask  <sub><sub><sub><del>{.prolog} ?- parent(X, Y). </del></sub></sub></sub>  ## Unification is a Powerful Way To Answer Queries  Finally, when we ask  <sub><sub><sub><del>{.prolog} ?- parent(X, Y). </del></sub></sub></sub>  Prolog checks if the above term <strong>can be unified</strong> with any <strong>known fact</strong> (term).  - If <strong>unification succeeds</strong> it replies <code>true</code> (and <strong>solutions</strong> for <code>X</code>, <code>Y</code>) - If <strong>unification fails</strong> it replies <code>false</code>   ## Unification is a Powerful Way To Answer Queries  Finally, when we ask  <sub><sub><sub><del>{.prolog} ?- parent(X, Y). </del></sub></sub></sub>  Prolog checks if the above term <strong>can be unified</strong> with any <strong>known fact</strong> (term).  - If <strong>unification succeeds</strong> it replies <code>true</code> (and <strong>solutions</strong> for <code>X</code>, <code>Y</code>)  ### This Query Has <strong>Many Solutions</strong>: All known facts  <sub><sub><sub><del>{.prolog} ?- parent(X, Y). X = kim, Y = holly ; X = margaret, Y = kim ; X = herbert, Y = margaret; X = john, Y = kim ; X = felix, Y = john ; X = albert, Y = felix ; X = albert, Y = dana ; X = felix, Y = maya .</del></sub></sub></sub>   # Unification Lets Prolog Answer Queries Magically!  ## Plan  ### Language  1. Terms 2. Facts 3. Queries (Implementation: Unification) 4. <strong>Rules</strong> 5. Programs (Implementation: Backtracking Search)  ### Programming  - Numeric Computation - Data Structures - Puzzle Solving  # Rules  # Digression: Conjunctions, Queries about MANY terms  ## Conjunction: Comma-separated Sequence of terms  Often useful to ask questions over <strong>multiple</strong> terms.  - For example, to determine if <code>margaret</code> is the <strong>grandparent</strong> of <code>holly</code>  ## Conjunction: Comma-separated Sequence of terms  Often useful to ask questions over <strong>multiple</strong> terms.  - For example, to determine if <code>margaret</code> is the <strong>grandparent</strong> of <code>holly</code>  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X), parent(X, holly).</del></sub></sub></sub>  - Is there a person <code>X</code> who is a child of <code>margaret</code> <strong>AND</strong> a parent of <code>holly</code> ?  - Is there <code>X</code> s.t. <code>parent(margaret, X)</code> <strong>AND</strong> <code>parent(X, holly)</code> ?    ## Conjunction: Comma-separated Sequence of terms  Often useful to ask questions over <strong>multiple</strong> terms.  - For example, to determine if <code>margaret</code> is the <strong>grandparent</strong> of <code>holly</code>  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X), parent(X, holly).</del></sub></sub></sub>  - Is there a person <code>X</code> who is a child of <code>margaret</code> <strong>AND</strong> a parent of <code>holly</code> ?  - Is there <code>X</code> s.t. <code>parent(margaret, X)</code> <strong>AND</strong> <code>parent(X, holly)</code> ?  ### Apparently  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X), parent(X, holly). X = kim.</del></sub></sub></sub>   ## Conjunction: Comma-separated Sequence of terms  Often useful to ask questions over <strong>multiple</strong> terms.  - For example, to find the <strong>great-grandparents</strong> of <code>kim</code>   ## Conjunction: Comma-separated Sequence of terms  Often useful to ask questions over <strong>multiple</strong> terms.  - For example, to find the <strong>great-grandparents</strong> of <code>kim</code>  <sub><sub><sub><del>{.prolog} ?- parent(GGP, GP), parent(GP, P), parent(P, kim).</del></sub></sub></sub>  <strong>Note:</strong> how we link the terms with a variable to capture relationships.  ## Conjunction: Comma-separated Sequence of terms  Often useful to ask questions over <strong>multiple</strong> terms.  - For example, to find the <strong>great-grandparents</strong> of <code>kim</code>  <sub><sub><sub><del>{.prolog} ?- parent(GGP, GP), parent(GP, P), parent(P, kim).</del></sub></sub></sub>  <strong>Note:</strong> how we link the terms with a variable to capture relationships.  Prolog finds appropriate <strong>unifiers</strong> and replies  <sub><sub><sub><del>{.prolog} ?- parent(margaret, X), parent(X, holly). GGP = john, GP = felix, P = albert.</del></sub></sub></sub>  i.e. <code>john</code> is a <strong>great-grandparent</strong> following the above chain.  ## QUIZ: Conjunctions  Which of these queries is true iff <code>margaret</code> and <code>kim</code> are (half-) <strong>siblings</strong>?  <strong>A.</strong> <code>parent(margaret, kim)</code>  <strong>B.</strong> <code>parent(margaret, X), parent(X, kim).</code>  <strong>C.</strong> <code>parent(kim, X), parent(X, margaret).</code>  <strong>D.</strong> <code>parent(margaret, X), parent(kim, X).</code>  <strong>E.</strong> <code>parent(X, margaret), parent(X, kim).</code>   ## Recap: Conjunctions  - Conjunctions let us mine the database for complex relationships…  - … but its cumbersome to <strong>repeatedly</strong> write down long queries  - We need a way to <strong>compose</strong> complex queries from simple queries…  # Rules  ## Rules: Complex Predicates from Simple Queries  ### Format  <sub><sub><sub><del>{.prolog} headQuery :- condQuery1, condQuery2, condQuery3,…</del></sub></sub></sub>  ## Rules: Complex Predicates from Simple Queries  ### Format  <sub><sub><sub><del>{.prolog} headQuery :- condQuery1, condQuery2, condQuery3,…</del></sub></sub></sub>  <br><br>  ### Intuition 1 (Forwards)  - <strong>If</strong> you can prove <code>condQuery1</code> <strong>AND</strong> <code>condQuery2</code> <strong>AND</strong> <code>...</code>  - <strong>Then</strong> you can prove <code>headQuery</code>  ## Rules: Complex Predicates from Simple Queries  ### Format  <sub><sub><sub><del>{.prolog} headQuery :- condQuery1, condQuery2, condQuery3,…</del></sub></sub></sub>  <br><br>  ### Intuition 2 (Backwards)  - To prove the <strong>goal</strong> <code>headQuery</code> …  - Prove <strong>subgoals</strong> <code>condQuery1</code> <strong>AND</strong> <code>condQuery2</code> <strong>AND</strong> …    ## Rules: Complex Predicates from Simple Queries  ### An Example: Defining a <code>grandparent</code> predicate  - Our database includes a <code>parent</code> predicate  - Let us use it to <strong>define</strong> a <code>grandparent</code> predicate  ## Rules: Complex Predicates from Simple Queries  ### An Example: Defining a <code>grandparent</code> predicate  <sub><sub><sub><del>{.prolog} grandparent(GP, GC) :- parent(GP, P), parent(P, GC).</del></sub></sub></sub>  <br>  ### Intuition  <code>GP</code> is a <em>grandparent</em> of <code>GC</code> if <code>GP</code> is a <em>parent</em> of <code>P</code> <strong>and</strong> <code>P</code> is a <em>parent</em> of <code>GC</code>  ## Rules: Complex Predicates from Simple Queries  ### An Example: Defining a <code>grandparent</code> predicate  <sub><sub><sub><del>{.prolog} grandparent(GP, GC) :- parent(GP, P), parent(P, GC).</del></sub></sub></sub>  ### Querying The Defined Predicate  <sub><sub><sub><del>{.prolog} ?- grandparent(X, kim). % who are the grandparents of kim X = herbert ; % hit ; to see next X = felix ; % hit ; to see next false. % thats it!</del></sub></sub></sub>  ## Rules: Complex Predicates from Simple Queries  ### An Example: Defining a <code>grandparent</code> predicate  <sub><sub><sub><del>{.prolog} grandparent(GP, GC) :- parent(GP, P), parent(P, GC).</del></sub></sub></sub>  ### Querying The Defined Predicate  <sub><sub><sub><del>{.prolog} ?- grandparent(X, kim). % who are the grandparents of kim X = herbert ; % hit ; to see next X = felix ; % hit ; to see next false. % thats it!</del></sub></sub></sub>  ### How? Because Prolog can prove  <sub><sub><sub><del>{.prolog} ?- parent(herbert, P), parent(P, kim). %% Solution 1. X = herbert P = margaret.  ?- parent(felix, P), parent(P, kim). %% Solution 2. X = felix P = john .</del></sub></sub></sub>  ## QUIZ: Complex Predicates from Simple Queries  Which of the following is a valid <code>greatgrandparent</code> predicate?  (Btw, <strong>greatgrandparent</strong> is the <strong>parent</strong> of a <strong>grandparent</strong>.)  bob -&gt; sachin -&gt; krishna -&gt; ranjit  <sub><sub><sub><del>{.prolog} % A greatgrandparent(X, Y) :- parent(X, Y), grandparent(X, Y).  % B greatgrandparent(X, Y) :- parent(X, Z), grandparent(Z, Y).  % C greatgrandparent(X, Y) :- grandparent(X, Z), parent(Z, Y).  % D greatgrandparent(X, Y) :- parent(X, Z), parent(Z, Y).  % E  greatgrandparent(X, Y) :- parent(X, Z), parent(Z, Z1), parent(Z1, Y).</del></sub></sub></sub>  anc(albert,DESC) parent(albert, felix) ==&gt; anc(felix, DESC) parent(albert, dana) ==&gt; anc(dana, DESC)   anc(X, Y) :- anc(Z1, Y), parent(X, Z1).   anc(albert,DESC) anc(Z1, DESC) anc(Z1’, DESC) anc(Z1’‘, DESC) anc(Z1’’’, DESC)   ## Rules: Complex Predicates from Simple Queries  ### An Example: Defining a <code>greatgrandparent</code> predicate  <sub><sub><sub><del>{.prolog} greatgrandparent(GGP, GC) :- parent(GGP, GP), grandparent(GP, GC).</del></sub></sub></sub>  ## Rules: Complex Predicates from Simple Queries  ### An Example: Defining a <code>greatgrandparent</code> predicate  <sub><sub><sub><del>{.prolog} greatgrandparent(GGP, GC) :- parent(GGP, GP), grandparent(GP, GC).</del></sub></sub></sub>  ### Querying The Defined Predicate  <sub><sub><sub><del>{.prolog} ?- greatgrandparent(X, holly). X = herbert.</del></sub></sub></sub>   # That was our first Prolog program!  ## Plan  ### Language  1. Terms 2. Facts 3. Queries (Implementation: Unification) 4. Rules 5. <strong>Programs</strong> (Implementation: Backtracking Search)  ### Programming  - Numeric Computation - Data Structures - Puzzle Solving   # Prolog Programs = Facts + Rules!  ## Prolog Programs = Facts + Rules!  Facts and Rules are two kinds of <strong>clauses</strong>  - <strong>Fact:</strong> Clause <strong>without</strong> any conditions  - <strong>Rules:</strong> Clause <strong>with</strong> conditions  ### Programs  - Basic Facts / Predicates  - Rules for <strong>generating</strong> new Facts / Predicates   ## Prolog Programs = Facts + Rules!  Complex Programs need Complex Predicates with Multiple Rules  1. Scope  2. Multiple Rules: Disjunction  3. Multiple Rules: Recursion   ## Prolog Programs = Facts + Rules!  Complex Programs need Complex Predicates with Multiple Rules  1. <strong>Scope</strong>  2. Multiple Rules: Disjunction  3. Multiple Rules: Recursion   ## Programs = Facts + Rules : Scope  A word about <strong>scope</strong>.  In the <code>grandparent</code> rule, the variable <code>GP</code> appears <strong>twice</strong>  <sub><sub><sub><del>{.prolog} greatgrandparent(GGP, GC) :- parent(GGP, GP), grandparent(GP, GC).</del></sub></sub></sub>  ### Scope: All Variables Are Local To A Single Rule  - In Prolog, the scope of a variable is the <strong>single</strong> rule containing it.  - There is <strong>no connection</strong> between variables <strong>across</strong> rules.  ## Programs = Facts + Rules : Scope  A word about <strong>scope</strong>.  ### Scope: All Variables Are Local To A Single Rule  - In Prolog, the scope of a variable is the <strong>single</strong> rule containing it.  - There is <strong>no connection</strong> between variables <strong>across</strong> rules.  ### Example  <sub><sub><sub><del>{.prolog} foo(P) :- bar(P). % There is no connection between P stuff(P) :- thing(P). % across the two rules</del></sub></sub></sub>  ## Prolog Programs = Facts + Rules!  Complex Programs need Complex Predicates with Multiple Rules  1. Scope  2. <strong>Multiple Rules: Disjunction</strong>  3. Multiple Rules: Recursion  ## Complex Predicates: Disjunction  Lets write a predicate <code>has_family</code> which is true for persons who  - <strong>either</strong> have a parent  - <strong>or</strong> have a child  ## Complex Predicates: Disjunction  Lets write a predicate <code>has_family</code> which is true for persons who  - <strong>either</strong> have a parent  - <strong>or</strong> have a child  <sub><sub><sub><del>{.prolog} has_family(X) :- parent(X, <em>). % if X is the parent of some </em> has_family(X) :- parent(<em>, X). % if X is the child of some </em></del></sub></sub></sub>  <code>_</code> is a <em>wildcard</em> or <em>dont-care</em> variable (as in ML, Scala)  ### Disjunction via Multiple Rules  - <strong>If</strong> we can prove <code>parent(X, _)</code> <strong>Then</strong> we can prove <code>has_family(X)</code>  - <strong>If</strong> we can prove <code>parent(_, X)</code> <strong>Then</strong> we can prove <code>has_family(X)</code>  ## Complex Predicates: Disjunction  Lets write a predicate <code>has_family</code> which is true for persons who  - <strong>either</strong> have a parent  - <strong>or</strong> have a child  <sub><sub><sub><del>{.prolog} has_family(X) :- parent(X, <em>). % if X is the parent of some </em> has_family(X) :- parent(<em>, X). % if X is the child of some </em></del></sub></sub></sub>  ### Executing the Query  <sub><sub><sub><del>{.prolog} ?- has_family(holly). true. % Second rule fires for holly  ?- has_family(mugatu). false. % Neither rule fires for mugatu</del></sub></sub></sub>  ## Complex Predicates: Disjunction  Lets write a predicate <code>has_family</code> which is true for persons who  - <strong>either</strong> have a parent  - <strong>or</strong> have a child  <sub><sub><sub><del>{.prolog} has_family(X) :- parent(X, <em>). % if X is the parent of some </em> has_family(X) :- parent(<em>, X). % if X is the child of some </em></del></sub></sub></sub>  Can be abbreviated to  <sub><sub><sub><del>{.prolog} has_family(X) :- parent(X, <em>) ; parent(</em>, X).</del></sub></sub></sub>  Semicolon <code>;</code> indicates disjunction.  ## Prolog Programs = Facts + Rules!  Complex Programs need Complex Predicates with Multiple Rules  1. Scope  2. Multiple Rules: Disjunction  3. <strong>Multiple Rules: Recursion</strong>  ## Complex Predicates: Recursion  Lets write a predicate <code>ancestor(Anc, Child)</code> which is true if  - <code>parent(Anc, Child)</code> … <strong>or</strong>  - <code>parent(Anc, P)</code> and <code>parent(P, Child)</code> … <strong>or</strong>  - <code>parent(Anc, GP)</code> and <code>parent(GP, P)</code> and <code>parent(P, Child)</code> … <strong>or</strong>  - … if <strong>some</strong> chain of parent-links holds between <code>Anc</code> and <code>Child</code>.  ## Complex Predicates: Recursion  Lets write a predicate <code>ancestor(Anc, Child)</code> which is true if  … if <strong>some</strong> chain of parent-links holds between <code>Anc</code> and <code>Child</code>.  ### Base Case  - If <code>Anc</code> is the parent of <code>Child</code>  - <code>ancestor(Anc, Child) :- parent(Anc, Child).</code>  ### Inductive Case  - If <code>P</code> is the parent of <code>Child</code> and <code>Anc</code> is an <strong>ancestor</strong> of <code>P</code>  - <code>ancestor(Anc, Child) :- parent(P, Child), ancestor(Anc, P).</code>  ## Complex Predicates: Recursion  Lets write a predicate <code>ancestor(Anc, Child)</code> which is true if  … if <strong>some</strong> chain of parent-links holds between <code>Anc</code> and <code>Child</code>.  <sub><sub><sub><del>{.prolog} ancestor(Anc, Child) :- parent(Anc, Child). ancestor(Anc, Child) :- parent(P, Child), ancestor(Anc, P).</del></sub></sub></sub>  ## Complex Predicates: Recursion  Lets write a predicate <code>ancestor(Anc, Child)</code> which is true if  … if <strong>some</strong> chain of parent-links holds between <code>Anc</code> and <code>Child</code>.  <sub><sub><sub><del>{.prolog} ancestor(Anc, Child) :- parent(Anc, Child). ancestor(Anc, Child) :- parent(P, Child), ancestor(Anc, P).</del></sub></sub></sub>  Lets take it out for a spin!  First, lets find <strong>descendants</strong> (forwards)  <sub><sub><sub><del>{.prolog} ?- ancestor(kim, X). X = holly.</del></sub></sub></sub>  ## Complex Predicates: Recursion  Lets write a predicate <code>ancestor(Anc, Child)</code> which is true if  … if <strong>some</strong> chain of parent-links holds between <code>Anc</code> and <code>Child</code>.  <sub><sub><sub><del>{.prolog} ancestor(Anc, Child) :- parent(Anc, Child). ancestor(Anc, Child) :- parent(P, Child), ancestor(Anc, P).</del></sub></sub></sub>  Lets take it out for a spin!  Next, lets find <strong>ancestors</strong> (backwards)  <sub><sub><sub><del>{.prolog} ?- ancestor(X,kim). X = margaret ; X = john ; X = herbert ; X = felix ; X = albert .</del></sub></sub></sub>  <code>kim</code> has a long ancestry!  # Pretty neat: go forward or back, in just 2 lines…  # …Try doing that in any other language!  ## Plan  ### Language  1. Terms 2. Facts 3. Queries (Implementation: Unification) 4. Rules 5. Programs (Implementation: <strong>Backtracking Search</strong>)  ################################################################################ ################################################################################ ################################################################################   ### Backtracking Search  TBD  ### Order Matters!  TBD  ### Language  1. Terms 2. Facts 3. Queries (Implementation: Unification) 4. Rules 5. <strong>Programs</strong> (Implementation: Backtracking)  ### Programming  - <strong>Numeric Computation</strong> - Data Structures - Puzzle Solving  ### Backtracking Search  How does prolog answer recursive queries?  - Brute force <em>backtracking search</em>  View each clause as a <strong>proof rule</strong>:  <sub><sub><sub><del>{.prolog} goal :- subgoal_1, subgoal_2,…</del></sub></sub></sub>  Thus, the rules for ancestor are as follows:  <sub><sub><sub><del>{.prolog} ancestor(X,Y) :- parent(X,Y). %rule 1 ancestor(X,Y) :- parent(Z,Y),ancestor(X,Z). %rule 2</del></sub></sub></sub>  To prolog, these rules mean “to prove <code>ancestor(X,Y)</code>, try to:  1. Prove the <em>subgoal</em> <code>parent(X,Y)</code>, or, <strong>failing that</strong>, 2. Prove the <em>subgoal</em> <code>parent(X,Z), **and then** the subgoal</code>ancestor(X,Z)<code>.  Suppose we ask it the query:   ~~~~~{.prolog} ?- ancestor(felix,holly). ~~~~~  To prove this query, it undertakes the following backtracking search:  - **NOTE** there are multiple</code>Z<code>variables (</code>Z’<code>and</code>Z’’<code>...) - These are introduced each time the corresponding sub-goals are triggered.  ~~~~~ 		ancestor(felix,holly)? 		  /		                \   parent(felix,holly)    parent(Z,holly) 	  NO		               ancestor(felix,Z) 				| 				| Z = kim  (by fact) 				| 			  ancestor(felix,kim) 			  /                \ 	  parent(felix,kim)     parent(Z',kim) 	      NO                ancestor(felix,Z')  ----------| 			                     |                            | Z'=john 		           Z'=margaret |                            | 				          |                             ancestor(felix,john) 		      ancestor(felix,margaret)                      | 		              /        \                      parent(felix,john) 	parent(felix,margaret)   parent(Z'',margaret)         YES 		          NO           ancestor(felix,Z'')                                       | 		                    Z'' = herbert | 		                                  | 			                  ancestor(felix, herbert) 			                 /              | 		 parent(felix,herbert)   parent(Z''',herbert) 		            NO			             NO ~~~~~  ### Queries with Variables  *Backtracking Search* is done for **every** query.  ~~~~~{.prolog}   ?- ancestor(X,kim). ~~~~~  - Prolog does the proof search - Returns **all** unifiers for</code>X<code>for which the proof succeeds with</code>YES<code>.  That is, literally programming by proving.  **Hint:** Trace mode in prolog shows the tree:  ~~~~~{.prolog} ?- trace. ?- help(trace). ~~~~~  The subsequent query is traced...  ### Order is Very Important!  - Order of clauses &amp; terms influences unification &amp; backtracking.  For each  - **goal** different clauses are selected in order, - **clause** subgoals unified from **left-to-right**.  ### Bad Order Causes Non-Termination!  So, different orders of recursive sub-query can cause **non-termination**  Suppose we wrote:  ~~~~~{.prolog} ancestor(X,Y) :- ancestor(X,Z), parent(Z,Y). ancestor(X,Y) :- parent(X,Y). ~~~~~  Then we see:  ~~~~~{.prolog}     ?- ancestor(felix,holly). ~~~~~  Why? The search tree looks like this now!  ~~~~~ 		ancestor(felix,holly)? 		  | 			| 			| 		ancestor(felix,Z)  %prove first subgoal, 			|          %then parent(Z,holly) 			| 			| 		ancestor(felix,Z') %prove first subgoal, 			|	   %then parent(Z',Z) 			| 			| 		ancestor(felix,Z'') 			. 			. 			. ~~~~~~  ### To Avoid Stack Overflow  - Place the</code>parent<code>subgoal **first** (in the recursive rule).  - Then unification with the base facts (parent), **fixes**</code>Z<code>- Thereby guaranteeing termination.  ### QUIZ  Which of these will terminate?  ~~~~~{.prolog} % A ancestor(X,Y) :- ancestor(X,Z), parent(Z,Y). ancestor(X,Y) :- parent(X,Y).  % B ancestor(X,Y) :- parent(X,Y). ancestor(X,Y) :- ancestor(X,Z), parent(Z,Y).  % C ancestor(X,Y) :- parent(X,Y). ancestor(X,Y) :- parent(Z,Y), ancestor(X,Z).  % D ancestor(X,Y) :- parent(Z,Y), ancestor(X,Z). ancestor(X,Y) :- parent(X,Y). ~~~~~  ### QUIZ  Lets define a</code>sibling<code>predicate:  -</code>sibling(X, Y)<code>if</code>X<code>and</code>Y<code>have the same</code>parent<code>.  ~~~~~{.prolog} % A sibling(X, Y) :- parent(P, X), parent(P, Y).  % B sibling(X, Y) :- parent(P, X), parent(P, Y), not(X = Y).  % C sibling(X, Y) :- not(X = Y), parent(P, X), parent(P, Y). ~~~~~    ### Ordering and Unification  Unfortunately to</code>prolog<code>~~~~~{.prolog} ?- X = Y. X = Y ~~~~~  is **always true**, and so the</code>not<code>**always fails**  ~~~~~{.prolog} ?- not(X = Y). false. ~~~~~  So the following query **always fails**  - if</code>X<code>and</code>Y<code>are variables!  ~~~~~{.prolog} sibling(X, Y) :- not(X = Y), parent(P, X), parent(P, Y). ~~~~~  ### Ensure Disequality Check After Unification  **Solution**  - Ensure goal</code>not(X=Y)<code>fires **after**</code>X<code>and</code>Y<code>are **unified to atoms**  ~~~~~{.prolog} sibling(X, Y) :- parent(P, X), parent(P, Y), not(X = Y). ~~~~~  and now we get:  ~~~~~{.prolog}     ?- sibling(X,Y).     X = john     Y = maya ;      X = felix     Y = dana ;      X = dana     Y = felix ;      X = maya     Y = john ;     No ~~~~~  ## Programming  Next, lets do some _programmaing_ in prolog.  - **Numeric Computation** - Data Structures - Puzzle Solving  ### Numeric Computation  Two big problems:  1. How do we even *evaluate*? e.g.</code>2 + 3<code>?  2. How do we write **functions** e.g.</code>let add x y = x + y<code>?  ### Problem 1: How to Evaluate?  - Everything is a _term_ and</code>=<code>is a **unification** operator:  ~~~~~{.prolog} ?- X = 2 + 3. X = 2 + 3 ~~~~~  - Pfft. To &quot;compute&quot; we need some **evaluation** mechanism!  ### Evaluation with the</code>is<code>Operator  The</code>is<code>operator lets us **evaluate** terms:  ~~~~~{.prolog} ?- X is 2 + 3. X = 5. ~~~~~  To solve</code>is<code>goal</code>TERM1 is TERM2<code>, prolog:  1. **Evaluates*</code>TERM2<code>and _then_ 2. **Unifies** result with</code>TERM1<code>.  However, watch out!  ~~~~~{.prolog} ?- Y is X+2, X=1. ERROR: Args are not sufficiently instantiated  ?- X=1, Y is X+2. X=1 Y=3 ~~~~~  - Variables must solved to numbers **before** evaluation.  - **Order of evaluation matters!**   ### Numeric Computation  Two big problems:  1. How do we even *evaluate*? e.g.</code>2 + 1<code>?  2. How do we write **functions** e.g.</code>let incr x = x + 1<code>?   ### Problem 2: How to Write Functions?  Oops. **Everything is a predicate** in prolog!  - Facts are the basic predicates, and - Rules let us get new facts from the basic ones.  How can we even _represent_ a **function** e.g.  ~~~~~{.ocaml} let add x y = x + y ~~~~~  using predicates?   ### QUIZ  Which of the following represents</code>let add x y = x + y<code>?  ~~~~~{.prolog} % A addP(X, Y) :- Z is X + Y.         % wtf is Z ?  % B addP(X, Y, Z) :- Z is X + Y.      % wtf is Z ?  % C addP(X, Y, X + Y).  % D addP(X, Y) :- X + Y.  % E addP(X, Y, Z) :- X + Y is Z. ~~~~~   ### Functions as Predicates  Every **function** of the form:  ~~~~~{.ocaml} let foo x y = out ~~~~~  corresponds to a **predicate** of the form:  ~~~~~{.ocaml} fooP(X, Y, OUT). ~~~~~  i.e. a predicate that is</code>True<code>for those triples</code>(X, Y, OUT)<code>s.t.  - The function</code>foo X Y<code>evaluated to</code>OUT<code>!  The</code>predicate<code>captures the **input-output relation** of the function.   ### Factorial  Lets write a predicate capturing the IO relationship of</code>factorial<code>:  ~~~~~{.prolog} factorial(X, OUT) ~~~~~  holds only when</code>OUT<code>is the factorial of</code>X`.  <sub><sub><sub><del>{.prolog} <strong>DO IN CLASS</strong></del></sub></sub></sub>  When we are done, we can <strong>call</strong> the function with a query:  <sub><sub><sub><del>{.prolog} ?- factorial(0, OUT). OUT = 1  ?- factorial(5, OUT). OUT = 120</del></sub></sub></sub>   ### Programming  - Numeric Computation - <strong>Data Structures</strong> - Puzzle Solving  ### Data Structures: Lists  TBD  ### Programming  - Numeric Computation - Data Structures - <strong>Puzzle Solving</strong>  ### Data Structures: Accumulators  TBD  ### Puzzle Solving  - Towers of Hanoi - Farmer, Wolf, Goat, Cabbage  ### Towers of Hanoi  TBD  ### Farmer, Wolf, Goat, Cabbage  TBD</p>
                <hr>
            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://nadia-polikarpova.github.io/cse130-sp18//feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/polikarn" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/nadia-polikarpova" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/jquery.min.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/spaceg.stylesheets.min.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/anim.js"></script>
<script src="https://nadia-polikarpova.github.io/cse130-sp18//static/js/scripts.js"></script>

    </body>
</html>
